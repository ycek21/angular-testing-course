Section 1

Jasmine is a behavoir driven Javascript testing framework and is available in angular.


A group of specifications is called a test suite. Specification is simply a funcitonal test.
Specification is meant to test a particular functional feature of an application.
Each Specification should be described by a sentence. It starts with fucntion 'it()'

describe("CalculatorService", () => {
  it("should add two numbers", () => {
    //it means test is not ready to run
    pending();
  });

  it("should add subtract numbers", () => {
    //simulate test fail
    fail();
  });
});




ng test --no-watch --- run tests without hot reload option


FIRST TESt
describe("CalculatorService", () => {
  it("should add two numbers", () => {
    const calculatorService = new CalculatorService(new LoggerService());

    const result = calculatorService.add(2, 2);

    expect(result).toBe(4);
  });

  it("should add subtract numbers", () => {
    const calculatorService = new CalculatorService(new LoggerService());

    const result = calculatorService.subtract(2, 2);

    expect(result).toBe(0, "unexpected subtraction result");
  });
});

JASMINE SPIES
Spying allows us to keep track how many times a function is called.
 We can provide a fake implementation and define a fake function return.
We can spy on existing object or we can mock it ourselves

describe("CalculatorService", () => {
  it("should add two numbers", () => {
    //const logger = new LoggerService();

    spyOn(logger, "log");


    // in the tested
    // const logger = jasmine.createSpyObj("LoggerService", ["log"]);

      return value if you need
   // logger.log.and.returnValue()

    // spyOn(logger, "log");

    const calculatorService = new CalculatorService(logger);

    const result = calculatorService.add(2, 2);

    expect(result).toBe(4);

    expect(logger.log).toHaveBeenCalledTimes(1);
  });


REPETITIVE CODE IN EVERY TEST
We can define beforeEach method to get rid of the duplicate code. Before each as the same suggests
is executed before every single test. Which means in the example below it will be called twice.


describe("CalculatorService", () => {
  let calculatorService: CalculatorService;
  let logger: LoggerService;

  beforeEach(() => {
    logger = jasmine.createSpyObj("LoggerService", ["log"]);

    calculatorService = new CalculatorService(logger);
  });

  it("should add two numbers", () => {
    const result = calculatorService.add(2, 2);

    expect(result).toBe(4);

    expect(logger.log).toHaveBeenCalledTimes(1);
  });

  it("should add subtract numbers", () => {
    const result = calculatorService.subtract(2, 2);

    expect(result).toBe(0, "unexpected subtraction result");

    expect(logger.log).toHaveBeenCalledTimes(1);
  });
});


USING DEPENDENCY INJECTION
Previously we were manually creating services. We can use dependency injection to
recreate standard environment.
Using testBed we simulate DI. We inject the actual CalculatorService and the
jasmine spy, which is a dependant service- logger service.
After that we inject it.

  beforeEach(() => {
    logger = jasmine.createSpyObj("LoggerService", ["log"]);

    TestBed.configureTestingModule({
      providers: [
        CalculatorService,
        { provide: LoggerService, useValue: logger },
      ],
    });

    calculatorService = TestBed.inject(CalculatorService);
  });

  it("should add two numbers", () => {
    const result = calculatorService.add(2, 2);

    expect(result).toBe(4);

    expect(logger.log).toHaveBeenCalledTimes(1);
  });

  it("should add subtract numbers", () => {
    const result = calculatorService.subtract(2, 2);

    expect(result).toBe(0, "unexpected subtraction result");

    expect(logger.log).toHaveBeenCalledTimes(1);
  });
});

SUMMARIZE
We define a series of functional specifications. So called it blocks. Their role is to
test one functionality of the service/ component.

Test consist of 3 element:
-setting up the necessary things usually via beforeEach block
-perform the operation we want to test
-run a series of assertions that will pass or not - result.toBe itp.

Always mock dependant dependencies. It's a key assumption, because we want to have complete isolation
of the service/ component we test. Otherwise we would have integrations tests instead of unit.
Test for one service should be implemented in a separate it block.


Disabling test:
xdescribe - disable whole block
xit - disable particular test
fdescribe - tylko te w tym describie
fit - tak samo tylko dla it


HTTP SERVICE TESTING
request is mocked using  FLUSH method. It will pass values to the subscribe.
Angular provides its own HttpClientTestingModule as well as the HttpTestingController


import { TestBed } from "@angular/core/testing";
import {
  HttpClientTestingModule,
  HttpTestingController,
} from "@angular/common/http/testing";
import { CoursesService } from "./courses.service";
import { COURSES } from "../../../../server/db-data";

describe("CoursesService", () => {
  let coursesService: CoursesService;
  let httpTestingController: HttpTestingController;

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [
        CoursesService,
        // adding HttpClient would sent actual requests. We only want to mock it
        // HttpClient
      ],
    });

    coursesService = TestBed.inject(CoursesService);
    httpTestingController = TestBed.inject(HttpTestingController);
  });

  it("should retrieve all courses", () => {
    coursesService.findAllCourses().subscribe((courses) => {
      expect(courses).toBeTruthy("No courses returned");
      expect(courses.length).toBe(12, "Incorrect number of courses");

      const course = courses.find((course) => course.id == 12);

      expect(course.titles.description).toBe("Angular Testing Course");
    });

    const req = httpTestingController.expectOne("/api/courses");

    expect(req.request.method).toEqual("GET");

    req.flush({ payload: Object.values(COURSES) });
  });
});


afterEach(() => {
    httpTestingController.verify();
  });


TESTING POSTING RESOURCES

  it("should save the course data", () => {
    const changes: Partial<Course> = {
      titles: { description: "Testing Course" },
    };

    coursesService.saveCourse(12, changes).subscribe((course) => {
      expect(course.id).toBe(12);
    });

    const req = httpTestingController.expectOne("/api/courses/12");

    expect(req.request.method).toEqual("PUT");
    expect(req.request.body.titles.description).toEqual(
      changes.titles.description
    );

    req.flush({
      ...COURSES[12],
      ...changes,
    });
  });

TESTING POSTING WITH ERROR RETURNED
  it("should give an error if save course fails", () => {
    const changes: Partial<Course> = {
      titles: { description: "Testing Course" },
    };

    coursesService.saveCourse(12, changes).subscribe(
      () => {
        fail("the save course opeartion should have failed");
      },
      (error: HttpErrorResponse) => {
        expect(error.status).toBe(500);
      }
    );

    const req = httpTestingController.expectOne("/api/courses/12");

    expect(req.request.method).toEqual("PUT");

    req.flush("Save course failed", {
      status: 500,
      statusText: "Internal server error",
    });
  });


CHECKING HTTP PARAMETERS
  it("sholud find a list of lessons", () => {
    coursesService.findLessons(12).subscribe((lessons) => {
      expect(lessons).toBeTruthy();
      expect(lessons.length).toBe(3);
    });

    const req = httpTestingController.expectOne(
      (req) => req.url == "/api/lessons"
    );

    expect(req.request.method).toEqual("GET");
    expect(req.request.params.get("courseId")).toEqual("12");
    expect(req.request.params.get("filter")).toEqual("");
    expect(req.request.params.get("sortOrder")).toEqual("asc");
    expect(req.request.params.get("pageNumber")).toEqual("0");
    expect(req.request.params.get("pageSize")).toEqual("3");

    req.flush({
      payload: findLessonsForCourse(12).slice(0, 3),
    });
  });



TESTING PRESENTIONAL COMPONENTS
using waitForAsync is necessary, because without that the test would execute before the fixture and component would be initialized.



describe("CoursesCardListComponent", () => {
  let component: CoursesCardListComponent;
  let fixture: ComponentFixture<CoursesCardListComponent>;
  let el: DebugElement;


  beforeEach(waitForAsync(() => {
    TestBed.configureTestingModule({
      imports: [CoursesModule],
    })
      .compileComponents()
      .then(() => {
        fixture = TestBed.createComponent(CoursesCardListComponent);
        component = fixture.componentInstance;
        el = fixture.debugElement
      });
  }));

  it("should create the component", () => {
    expect(component).toBeTruthy();
    console.log("component :>> ", component);
  });

  it("should display the course list", () => {
    pending();
  });

  it("should display the first course", () => {
    pending();
  });
});

YOU HAVE TO MANUALLY DETECT CHANGES AFTER CHANGING COMPONENT'S INPUT.
WHAT ARE WE DOING HERE. FIRST WE INITIALIZE COURSE PROPERTY, AFTER THAT WE DETECT CHANGES.
THEN WE USE THE PREDEFINED DEBUGELEMENT AND WE QUERY APPROPRIATE CLASSES TO.

  it("should display the first course", () => {
    component.courses = Object.values(COURSES);

    fixture.detectChanges();

    const course = component.courses[0];

    const card = el.query(By.css(".course-card:first-child")),
      title = card.query(By.css("mat-card-title")),
      image = card.query(By.css("img"));

    expect(card).toBeTruthy("First course doesn't exist");
    expect(title.nativeElement.textContent).toBe(course.titles.description);
    expect(image.nativeElement.src).toBe(course.iconUrl);
  });

TESTING SMART COMPONENT

describe("HomeComponent", () => {
  let fixture: ComponentFixture<HomeComponent>;
  let component: HomeComponent;
  let el: DebugElement;

  beforeEach(waitForAsync(() => {
    const coursesServiceSpy = jasmine.createSpyObj("CoursesService", [
      "findAllCourses",
    ]);

    TestBed.configureTestingModule({
      imports: [CoursesModule, NoopAnimationsModule],
      providers: [{ provide: CoursesService, useValue: coursesServiceSpy }],
    })
      .compileComponents()
      .then(() => {
        fixture = TestBed.createComponent(HomeComponent);
        component = fixture.componentInstance;
        el = fixture.debugElement;
      });
  }));